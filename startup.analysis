Данный кейс направлен на анализ стартапа, который продаёт продукты питания. Цель анализа - разобраться, как ведут себя пользователи мобильного приложения. Задачи, которые будут выполнены для достижения цели:
изучение воронки продаж.
исследование результатов A/A/B-эксперимента.

1  Подготовка данных
import pandas as pd
import datetime as dt
import numpy as np
import matplotlib.pyplot as plt
from pandas.plotting import register_matplotlib_converters
import warnings
import scipy.stats as stats
import math as mth
from scipy import stats as st
import warnings 
warnings.filterwarnings('ignore')

data = pd.read_csv('/datasets/logs_exp.csv', sep = '\t')
#Изменение заголовков
data.columns = ['event_name', 'device_id', 'event_timestamp', 'exp_id']
#Добавление столбца с датами
data['date_time']=pd.to_datetime(data['event_timestamp'], unit='s')
display(data.head(10))

#проверка на дубликаты, пропуски и тип данных
print('Количество дубликатов в данных:', data.duplicated().sum())
display(data.info())
data.isna().sum()

#удаление дубликатов из данных и изменение типа данных
data['device_id'] = data['device_id'].astype(str)
data['exp_id'] = data['exp_id'].astype(str)
data = data.drop_duplicates()
display(data.info())
display(data.head(10))

#Проверка отсутствия пересечения пользователей в группах
users_aab = data.groupby('device_id')['exp_id'].nunique()
users_aab[users_aab > 1].count()

Таким образом, была проведена обработка данных: даты приведены к общему виду, изменены названия столбцов, проверены дубликаты, пропуски и типы данных, а также было выявлено, что пользователи в группах не пересекаются, каждый пользователь состоит только в 1 группе.

2  Изучение и проверка данных
2.1  Количество событий в логе

events_count = data.groupby('event_name').agg({'device_id': 'count'}).sort_values(by='device_id', ascending=False)
print(events_count)
sum_events_count = events_count['device_id'].sum()
print('Количество событий:', sum_events_count)
                         
2.2  Количество пользователей в логе

users_count = data.groupby('event_name').agg({'device_id': 'nunique'}).sort_values(by='device_id', ascending=False)
print(users_count)
sum_users_count = users_count['device_id'].sum()
print('Количество пользователей:', sum_users_count)
                         
2.3  Cреднее количество событий на пользователя

data_events = data.pivot_table(index='device_id',values='event_name',aggfunc='count')
print(data_events.describe())
print('Cреднее количество событий на пользователя:', round(data_events['event_name'].median(), 1))
       
На данном этапе видно, сколько человек дошли до каждого этапа продуктовой воронки. Только 62% зашедших на главную страницу в мобильном приложении пользователей перешли на страницу с предложением товара. В рамках остальных шагов все выглядит логично: 81% просмотревших предложение добавили товар в корзину и 95% оплатили заказ, что является хорошими показателями.
Среднее значение событий на каждого пользоватлея - 20, была использована медиана вместо среднего значения, так как в данных есть выбросы (разброс значений слишком велик).

2.4  Период данных

#Максимальная и минимальная дата в данных
min_date = data['date_time'].min()
print('Минимальная дата:', min_date)
max_date =data['date_time'].max()
print('Максимальная дата:', max_date)

#пострение графика количества пользователей по времени
data.pivot_table(
    index = 'date_time',
    values = 'device_id',
    aggfunc = 'nunique'
).plot(figsize=(15, 5), grid = True)
plt.title('Количество пользователей')
plt.ylabel('Количество событий')
plt.show()

Данные представлены за период меньше месяца: с 25 июля по 7 августа. При этом, по графику видно, что первую половину периода количество пользователей находится на уровне 1, а с 1 августа количество начинает резко расти. Поэтому нельзя быть уверенными в том, что данные представлены в полном объеме за весь период и необходимо отбросить данные до 1 августа.

2.5  Удаление данных

data_new = data.query('date_time > "2019-07-31"')
data_new.pivot_table(
    index = 'date_time',
    values = 'device_id',
    aggfunc = 'nunique'
).plot(figsize=(15, 5), grid = True)
plt.title('Количество пользователей')
plt.ylabel('Количество событий')
plt.show()

# Количество событий и пользователей в логе после удаления данных
data_old = data.query('date_time <= "2019-07-31"')
print('Количество потерянных событий:', len(data_old['event_name']))
devices_lost = 0
for row in data_new:
    if row not in data_old['device_id'].unique():
        devices_lost +=1 
print('Количество потерянных пользователей:', devices_lost)

users_exp_count = data_new.groupby(data_new['exp_id']).agg({'device_id': 'nunique'}).sort_values(by='device_id', ascending = False)
print(users_exp_count)
        
Таким образом, в данных есть пользователи из всех экспериментальных групп, данные верны и анализ можно продолжать. Предварительно данные быыли отфильтрованы по количеству пользователей, неактуальные данные использоваться далее не будут.

3  Изучение воронки событий
3.1  Cобытия в логах, их частота.

# Количество событий и пользователей в логе после удаления данных
events_count_new = data_new.groupby('event_name').agg({'device_id': 'count'}).sort_values(by='device_id', ascending=False)
print(events_count_new)
                         
Как было видно ранее в логе есть следующие события: показ пользователю главного экрана, далее показ страницы с предложением, показ корзины, подтверждение оплаты, показ обучения.
3.2  Количество пользователей, совершивших каждое из событий. Доля пользователей, которые хоть раз совершали событие.

users_count_new = data_new.groupby('event_name').agg({'device_id': 'nunique'}).sort_values(by='device_id', ascending=False)
users_count_new['share_users']=round(users_count_new['device_id']/len(data_new['device_id'].unique()), 3) * 100
print(users_count_new)
                      
Количество пользователей логично укладывается в воронку событий: самым популярным явлется показ основной страницы приложения и далее по убыванию пользователи переходя на страницу предложения, корзины, оплаты и обучения.

3.3  Порядок событий.
Предположительно, воронка продаж следующая:
пользователь видит главный экран сайта
пользователь переходит на понравившийся ему товар
пользоватеь добавляет товар в корзину и переходит в нее
пользователь оплачивает заказ
Однако, есть вопрос к последнему событию в воронке - обучение. Необходимо понимать, обучение чему предпологает данное приложение, ведь до данного события доходит меньше всего пользователей. Возможно, данное событие вообще не входит в воронку.
3.4  Доля пользователей, проходящая на следующий шаг воронки.

users_count_new['conversion'] = 0
for i in range(0, len(users_count_new['share_users'])):
    if i == 0:
        users_count_new['conversion'].iloc[i] = 100
    else:
        users_count_new['conversion'].iloc[i] = round(int(users_count_new['device_id'].iloc[i]) / int(users_count_new['device_id'].iloc[i-1]), 2)*100
display(users_count_new)

По таблице можно увидеть, что сильная просадка идет сразу в двух событиях - когда пользователь переходи на страницу с предложением, а также при переходе на обучающую страницу, именно с ними необходмо работать для увеличения количества пользователей, совершивших покупку.

3.5  Шаг, на котором теряется больше всего пользователей.
Так, 62% пользователей переходит с главной страницы на страницу с предложением, 81% переходит в корзину, 95% оплачивают свой заказ и 24% обращаются к странице с обучением.
Можно предположить, что проблема в главной странице мобильного приложения - слишком мало пользователей идут дальше по воронке событий. Меньше всего пользователей в событии с оплатой заказа, что является логичным числом - далеко не все пользователи совершают покупку. Тем более, если смотреть не на абсолютное значение, а на конверсию, то очень большой процент пользователей переходит от предложения и страницы с корзиной к оплате, 95% является отличным показателем.

3.6  Доля пользователей, доходящих от первого события до оплаты.

print('Доля пользователей, доходящих от первого события до оплаты:', round(users_count_new['device_id'].iloc[3]/users_count_new['device_id'].iloc[0], 2)*100)

Таким образом, можно сделать вывод, что почти половина пользователей доходит от главной страницы мобильного приложения до оплаты. То есть можно сделать упор на маркетинговую кампанию или улучшение/оптимизацию главной страницы, чтобы просадка по количеству пользователей, заинтересовавшихся страницей с предложением, была как можно меньше.

import plotly.express as px
chart = dict(
    number=[7429, 4606, 3742, 3542, 845],
    stage=['MainScreenAppear', 'OffersScreenAppear', 'CartScreenAppear', 'PaymentScreenSuccessful', 'Tutorial'])
fig = px.funnel(chart, x='number', y='stage')
fig.show()

4  Результаты эксперимента
4.1  Количество пользователей в каждой экспериментальной группе.

data_groups = data_new.pivot_table(index='exp_id',values='device_id',aggfunc='nunique')
display(data_groups.sort_values(by = 'device_id', ascending = True))

246 и 247 — контрольные группы, а 248 — экспериментальная, в которой находится больше всего пользователей.
4.2  Статистические критерии разницу между выборками 246 и 247. Самое популярное событие.

final_data = data_new.pivot_table(index='exp_id',columns = 'event_name', values='device_id',aggfunc='nunique')
final_data['Total'] = final_data.sum(axis=1)
#final_data['Total']['device_id'][0] = 1267+2452+1544+1200+278
display(final_data)

#Функция для проверки гипотез, которая будет использоваться и в следующих пунктах
def test (success, trials, alpha):
    # пропорция успехов в первой группе:
    p1 = success[0] / trials[0]
    # пропорция успехов во второй группе:
    p2 = success[1] / trials[1]
    # пропорция успехов в комбинированном датасете:
    p_combined = (success[0] + success[1]) / (trials[0] + trials[1])
    # разница пропорций в датасетах
    difference = p1 - p2
 
    z_value = difference / mth.sqrt(p_combined *(1-p_combined) * (1/trials[0] + 1/trials[1]))
    
    distr = st.norm(0, 1) 
    
    p_value = (1 - distr.cdf(abs(z_value))) * 2
    
    print('p-значение:', p_value)
    
    if (p_value < alpha):
        print("Отвергаем нулевую гипотезу: между долями есть значимая разница")
        print('')
    else:
        print("Не получилось отвергнуть нулевую гипотезу, нет оснований считать доли разными")
        print('')

# Функция, которая возвращает результаты проверки гипотез
def automation (group1, group2, alpha):
    alpha_test = alpha
    count_users = ([final_data['Total'][group1], final_data['Total'][group2]])
    count_MainScreenAppear = ([final_data['MainScreenAppear'][group1], final_data['MainScreenAppear'][group2]])
    count_OffersScreenAppear = ([final_data['OffersScreenAppear'][group1], final_data['OffersScreenAppear'][group2]])
    count_CartScreenAppear = ([final_data['CartScreenAppear'][group1], final_data['CartScreenAppear'][group2]])
    count_PaymentScreenSuccessful = ([final_data['PaymentScreenSuccessful'][group1], final_data['PaymentScreenSuccessful'][group2]])
    
    print('Результаты теста по долям count_users и count_MainScreenAppear для групп')
    test(count_MainScreenAppear, count_users, alpha_test)
    
    print('Результаты теста по долям count_OffersScreenAppear и count_users для групп')
    test(count_OffersScreenAppear, count_users, alpha_test)
    
    print('Результаты теста по долям count_users и count_CartScreenAppear для групп')
    test(count_CartScreenAppear, count_users, alpha_test)
    
    print('Результаты теста по долям count_PaymentScreenSuccessful и count_users для групп')
    test(count_PaymentScreenSuccessful, count_users, alpha_test)

#Нулевая гипотеза: Доли в двух выборках равны.
#Альтернативная гипотеза: Доли в двух выборках не равны.

#Проверка контрольных групп А/A
automation (0, 1, 0.01)

По результатми анализа нет оснований считать контрольные выборки групп 246 и 247 разными, получается, контрольные группы выбраны верно.
Самым популярным событием, как и ожидалось, становится показ главного экрана сайта, с которой начинается воронка продаж.

4.3  Анализ группы с изменённым шрифтом.

#Нулевая гипотеза: Доли в двух выборках равны.
#Альтернативная гипотеза: Доли в двух выборках не равны.
​
#Соединение контрольных групп
final_data.loc['sum(246+247)'] = [final_data['CartScreenAppear'][0]+final_data['CartScreenAppear'][1], final_data['MainScreenAppear'][0]+final_data['MainScreenAppear'][1], final_data['OffersScreenAppear'][0]+final_data['OffersScreenAppear'][1], final_data['PaymentScreenSuccessful'][0]+final_data['PaymentScreenSuccessful'][1], final_data['Tutorial'][0]+final_data['Tutorial'][1], final_data['Total'][0]+final_data['Total'][1]]
display(final_data)

print('Процент пользователей 246-ой контрольной группы, которые переходят к оплате:', round(final_data['CartScreenAppear'].iloc[0]/final_data['Total'].iloc[1], 2)*100)
print('Процент пользователей 248-ой группы (с измененными шрифтами), которые переходят к оплате:', round(final_data['CartScreenAppear'].iloc[2]/final_data['Total'].iloc[2], 2)*100)

#Проверка групп 246 и 248
automation (0, 2, 0.01)

#Проверка групп 247 и 248
automation (1, 2, 0.01)

#Проверка групп sum и 248
automation (3, 2, 0.01)

Процент пользователей, которые перешли к оплате, больше в группе, чем в группе с измененным шрифтом. Значимой разницы в переходах объединенной контрольной группы с 248-ой группой нет, также как и при сравнении с каждой контрольной группой по-отдельности.

4.4  Уровни значимости.

#Вместо значения альфа равное 0.01 изменим его на 0.05

#Проверка групп 246 и 247
automation (0, 1, 0.05)

#Проверка групп 246 и 248
automation (0, 2, 0.05)

#Проверка групп 247 и 248
automation (1, 2, 0.05)

#Проверка групп sum и 248
automation (2, 3, 0.05)

При увеличении значения альфа на 5% значимая разница в группах не появляется, таким образом, доли во всех выборках равны при любом условии.

# Так как было проведено 16 проверок статистических гипотез необходимо применить метод Шидака для поправки множественности
# 4 воронки по 4 шага, получается, что m = 16
shidak_alpha = 1 - (pow(0.95, 1/16))
print(shidak_alpha)
Не получилось отвергнуть нулевую гипотезу, нет оснований считать доли разными

automation (0, 2, shidak_alpha)

automation (1, 2, shidak_alpha)

automation (2, 3, shidak_alpha)

Так, при помощи метода Шидока было еще раз подтверждено, что нет оснований считать доли групп разными и изменение шрифтов никак не повлияло на поведение пользователей.

5  Выводы
В данном кейсе было проанализировано мобильное приложение с точки зрения поведения его пользователей.
Воронка продаж, отсортированная по популярности события, выглядит следующим образом:
пользователь видит главный экран сайта
пользователь переходит на понравившийся ему товар
пользоватеь добавляет товар в корзину и переходит в нее
пользователь оплачивает заказ
Только 62% зашедших на главную страницу в мобильном приложении пользователей перешли на страницу с предложением товара. 81% просмотревших предложение добавили товар в корзину и 95% оплатили заказ, что является хорошими показателями. Таким образом, упор необходимо делить именно на шаге перехода пользователя с главной страницы на страницу с предложением товара, повышать процент данных пользователей.
Также необходимо обратить внимание на то, что почти половина пользователей доходит от просмотра главной страницы мобильного приложения до оплаты. То есть можно сделать упор на маркетинговую кампанию или улучшение/оптимизацию главной страницы, чтобы просадка по количеству пользователей, заинтересовавшихся страницей с предложением, была как можно меньше.
Таким образом, было принято решение проанализировать, как изменится поведение покупателей при изменении шрифта текста.
Тестирование показало, что нет оснований считать контрольные выборки групп 246 и 247 разными. Самым популярным событием в каждой группе, как и ожидалось, становится показ главного экрана сайта, с которой начинается воронка продаж. Процент пользователей, которые перешли к оплате, больше в контрольной группе, чем в группе с измененным шрифтом. Значимой разницы между объединенной контрольной группой, отдельными контрольными группами и группой с измененным шрифтом нет, поэтому можно считать, что изменение шрифта текста не оказывает значительное влияние на пользователей мобильного приложения.
